# Add .data to the global variables in order to avoid NOTEs from R CMD check
utils::globalVariables(c(".data"))

gsaot_indices <- function(method, indices, bound, IS, partitions, x, y, extended_out,
                          Adv = NULL, Diff = NULL) {
  value <- list(method = method, indices = indices, bound = bound,
                x = x, y = y)
  if (extended_out) {
    value[["inner_statistics"]] <- IS
    value[["partitions"]] <- partitions
  }

  if (!is.null(Adv)) {
    value[["adv"]] <- Adv
    value[["diff"]] <- Diff
  }

  attr(value, "class") <- "gsaot_indices"

  return(value)
}

#' Print Optimal Transport Sensitivity indices information
#'
#' @param x An object generated by \code{\link{ot_indices}}, \code{\link{ot_indices_1d}}, or \code{\link{ot_indices_wb}}.
#' @param data Logical, indicating whether or not the input and output data should be printed.
#' @param ... Further arguments passed to or from other methods.
#'
#' @export
#'
#' @examples
#' N <- 1000
#'
#' mx <- c(1, 1, 1)
#' Sigmax <- matrix(data = c(1, 0.5, 0.5, 0.5, 1, 0.5, 0.5, 0.5, 1), nrow = 3)
#'
#' x1 <- rnorm(N)
#' x2 <- rnorm(N)
#' x3 <- rnorm(N)
#'
#' x <- cbind(x1, x2, x3)
#' x <- mx + x %*% chol(Sigmax)
#'
#' A <- matrix(data = c(4, -2, 1, 2, 5, -1), nrow = 2, byrow = TRUE)
#' y <- t(A %*% t(x))
#'
#' x <- data.frame(x)
#'
#' M <- 25
#'
#' # Calculate sensitivity indices
#' sensitivity_indices <- ot_indices(x, y, M)
#' print(sensitivity_indices)
#'
#' # With extended output
#' sensitivity_indices_extended <- ot_indices(x, y, M, extended_out = TRUE)
#' print(sensitivity_indices_extended)
#'
print.gsaot_indices <- function(x, data = FALSE, ...) {
  cat("Method:", x$method, "\n")
  cat("\nIndices:\n")
  print(x$indices)
  cat("\nUpper bound:", x$bound, "\n")
  # if (exists("inner_statistics", where = x)) {
  #   cat("Inner statistics:\n")
  #   print(x$inner_statistics)
  #   cat("Partitions:\n")
  #   print(x$partitions)
  # }
  if (data) {
    cat("Data:\n")
    print(x$x)
    print(x$y)
  }
  if (exists("adv", where = x)) {
    cat("\nAdvective component:\n")
    print(x$adv)
    cat("\nDiffusive component:\n")
    print(x$diff)
  }
}

#' Plot Optimal Transport sensitivity indices
#'
#' Plot Optimal Transport based sensitivity indices using `ggplot2` package.
#'
#' @param x An object generated by \code{\link{ot_indices}}, \code{\link{ot_indices_1d}}, or \code{\link{ot_indices_wb}}.
#' @param ranking An integer with absolute value less or equal than the number of inputs. If positive, select the first `ranking` inputs per importance. If negative, select the last `ranking` inputs per importance.
#' @param ... Further arguments passed to or from other methods.
#'
#'
#' @returns A \code{ggplot} object that, if called, will print
#' @export
#'
#' @examples
#' N <- 1000
#'
#' mx <- c(1, 1, 1)
#' Sigmax <- matrix(data = c(1, 0.5, 0.5, 0.5, 1, 0.5, 0.5, 0.5, 1), nrow = 3)
#'
#' x1 <- rnorm(N)
#' x2 <- rnorm(N)
#' x3 <- rnorm(N)
#'
#' x <- cbind(x1, x2, x3)
#' x <- mx + x %*% chol(Sigmax)
#'
#' A <- matrix(data = c(4, -2, 1, 2, 5, -1), nrow = 2, byrow = TRUE)
#' y <- t(A %*% t(x))
#'
#' x <- data.frame(x)
#'
#' M <- 25
#'
#' # Calculate sensitivity indices
#' sensitivity_indices <- ot_indices(x, y, M)
#' sensitivity_indices
#'
#' plot(sensitivity_indices)
#'
#' # With extended output
#' sensitivity_indices_extended <- ot_indices(x, y, M, extended_out = TRUE)
#' sensitivity_indices_extended
#'
#' plot(sensitivity_indices_extended)
#'
plot.gsaot_indices <- function(x, ranking = NULL, ...) {
  # If ranking is defined, plot only the selected inputs
  N <- nrow(x$indices)

  if (!is.null(ranking)) {
    if (ranking %% 1 == 0 & abs(ranking) <= N) {
      inputs_to_plot <- ifelse(rep(sign(ranking), each = abs(ranking)) > 0,
                               seq(ranking),
                               seq(from = N + ranking + 1, to = N))
    } else
      stop("`ranking` should be an integer with absolute value less than the number of inputs")
  } else
    inputs_to_plot <- seq(N)

  # If the indices are not from ot_indices_wb, print only the indices
  # Otherwise, plot the indices, the advective component and the diffusive one
  if (!exists("adv", where = x)) {
    # Create a data.frame to store all the indices
    x_indices <- data.frame(Inputs = names(x$indices[order(x$indices, decreasing = TRUE)])[inputs_to_plot],
                            Indices = unname(x$indices[order(x$indices, decreasing = TRUE)])[inputs_to_plot])
    x_indices$Inputs <- factor(x_indices$Inputs,
                               levels = unique(x_indices$Inputs))

    # Plot the indices ordered by magnitude
    ggplot2::ggplot(data = x_indices, ggplot2::aes(x = .data[["Inputs"]],
                                                   y = .data[["Indices"]])) +
      ggplot2::geom_bar(stat = "identity", fill = "#2d3650") +
      ggplot2::scale_y_continuous(limits = c(0,1)) +
      ggplot2::labs(title = paste("Indices calculated using", x$method, "solver"),
           x = "Inputs", y = "Indices")
  } else {
    # Create a data.frame to store all the indices
    x_indices <- data.frame(Inputs = rep(names(x$indices[order(x$indices, decreasing = TRUE)])[inputs_to_plot], times = 3),
                            Component = rep(c("WB", "Advective", "Diffusive"), each = length(inputs_to_plot)),
                            Indices = c(unname(x$indices[order(x$indices, decreasing = TRUE)])[inputs_to_plot],
                                        unname(x$adv[order(x$indices, decreasing = TRUE)])[inputs_to_plot],
                                        unname(x$diff[order(x$indices, decreasing = TRUE)])[inputs_to_plot]))
    x_indices$Inputs <- factor(x_indices$Inputs,
                               levels = unique(x_indices$Inputs))
    x_indices$Component <- factor(x_indices$Component,
                                  levels = unique(x_indices$Component))

    ggplot2::ggplot(data = x_indices, ggplot2::aes(x = .data[["Inputs"]],
                                                   y = .data[["Indices"]],
                                                   fill = .data[["Component"]])) +
      ggplot2::geom_bar(stat = "identity",
                        position = ggplot2::position_dodge2(padding = 0.2),
                        width = .7) +
      ggplot2::scale_y_continuous(limits = c(0,1)) +
      ggplot2::labs(title = paste("Indices calculated using", x$method, "solver"),
           x = "Inputs", y = "Indices") +
      ggplot2::scale_fill_manual(values = c("#2d3650", "#d5bfd4", "#ffef89"))
  }
}

#' Plot Optimal Transport inner statistics
#'
#' Plot Optimal Transport based inner statistics for each partition.
#'
#' @param x An object generated by \code{\link{ot_indices}}, \code{\link{ot_indices_1d}}, or \code{\link{ot_indices_wb}}.
#' @param ... Further arguments passed to or from other methods.
#'
#' @export
#'
#' @examples
#' N <- 1000
#'
#' mx <- c(1, 1, 1)
#' Sigmax <- matrix(data = c(1, 0.5, 0.5, 0.5, 1, 0.5, 0.5, 0.5, 1), nrow = 3)
#'
#' x1 <- rnorm(N)
#' x2 <- rnorm(N)
#' x3 <- rnorm(N)
#'
#' x <- cbind(x1, x2, x3)
#' x <- mx + x %*% chol(Sigmax)
#'
#' A <- matrix(data = c(4, -2, 1, 2, 5, -1), nrow = 2, byrow = TRUE)
#' y <- t(A %*% t(x))
#'
#' x <- data.frame(x)
#'
#' M <- 25
#'
#' # With extended output
#' sensitivity_indices_extended <- ot_indices(x, y, M, extended_out = TRUE)
#' plot_inner_stats(sensitivity_indices_extended)
#'
plot_inner_stats <- function(x, ...) {
  if (!exists("inner_statistics", where = x))
    stop("You have to save the inner statistics (use extended_out=TRUE)")

  # Save current plot settings to be restored after
  old_param <- graphics::par(no.readonly = TRUE)

  # Get the number of inputs
  K <- ncol(x$x)

  # Get the names of the inputs
  input_names <- names(x$indices)

  # Set the environment
  graphics::par(mfrow = c(K, 1))
  if (x$method == "wasserstein-bures") graphics::par(mfrow = c(K, 3))

  # Get the extrema for each set of inputs for the plot
  min_checkNA <- function(.x) {
    if(any(is.na(as.numeric(.x)))) NA
    else min(as.numeric(.x))
  }
  max_checkNA <- function(.x) {
    if(any(is.na(as.numeric(.x)))) NA
    else max(as.numeric(.x))
  }
  suppressWarnings(x_mins <- apply(x$x, 2, min_checkNA))
  suppressWarnings(x_maxs <- apply(x$x, 2, max_checkNA))

  for (k in seq(K)) {
    partition <- x$partitions[[k]]
    M <- length(partition)

    # If the input is numeric, get the mean of each partition as a x-point to be plotted
    if (is.numeric(x$x[, k])) {
      x_means <- array(dim = M)

      for (m in seq(M))
        x_means[m] <- mean(x$x[partition[[m]], k])

      # Set the limits if numeric
      xlim <- c(x_mins[k], x_maxs[k])

      # Plot the inner statistics
      graphics::plot(x_means, x$inner_statistics[[k]][1, ],
                     xlim = xlim,  ylim = c(0, 1),
                     xlab = input_names[k], ylab = "Index", ...)
      graphics::title(main = paste("Indices calculated using", x$method, "solver"))

      # Plot the advective and diffusive components if wb
      if (x$method == "wasserstein-bures") {
        graphics::plot(x_means, x$inner_statistics[[k]][2, ],
                       xlim = xlim, ylim = c(0, 1),
                       xlab = input_names[k], ylab = "Index", ...)
        graphics::title(main = paste("Advective component"))
        graphics::plot(x_means, x$inner_statistics[[k]][3, ],
                       xlim = xlim,  ylim = c(0, 1),
                       xlab = input_names[k], ylab = "Index", ...)
        graphics::title(main = paste("Diffusive component"))
      }
    } else {
    # If the input is non-numeric, use barplot
      if (is.factor(x$x[, k])) {
        x_unique <- levels(x$x[, k])
      } else {
        x_unique <- unique(x$x[, k])
      }

      # Plot the inner statistics
      graphics::barplot(x$inner_statistics[[k]][1, ],
                        names.arg = x_unique,  ylim = c(0, 1),
                        xlab = input_names[k], ylab = "Index", ...)
      graphics::title(main = paste("Indices calculated using", x$method, "solver"))

      # Plot the advective and diffusive components if wb
      if (x$method == "wasserstein-bures") {
        graphics::barplot(x$inner_statistics[[k]][2, ],
                          names.arg = x_unique,  ylim = c(0, 1),
                          xlab = input_names[k], ylab = "Index", ...)
        graphics::title(main = paste("Advective component"))
        graphics::barplot(x$inner_statistics[[k]][3, ],
                          names.arg = x_unique,  ylim = c(0, 1),
                          xlab = input_names[k], ylab = "Index", ...)
        graphics::title(main = paste("Diffusive component"))
      }
    }
  }

  graphics::par(old_param)
}
