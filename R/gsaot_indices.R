gsaot_indices <- function(method, indices, bound, IS, partitions, x, y, extended_out,
                          Adv = NULL, Diff = NULL) {
  value <- list(method = method, indices = indices, bound = bound,
                x = x, y = y)
  if (extended_out) {
    value[["inner_statistics"]] <- IS
    value[["partitions"]] <- partitions
  }

  if (!is.null(Adv)) {
    value[["adv"]] <- Adv
    value[["diff"]] <- Diff
  }

  attr(value, "class") <- "gsaot_indices"

  return(value)
}

#' Print Optimal Transport Sensitivity indices information
#'
#' @param x An object generated by \code{\link{ot_indices}}, \code{\link{ot_indices_1d}}, or \code{\link{ot_indices_wb}}.
#' @param data Logical, indicating whether or not the input and output data should be printed.
#' @param ... Further arguments passed to or from other methods.
#'
#' @export
#'
#' @examples
#' N <- 1000
#'
#' mx <- c(1, 1, 1)
#' Sigmax <- matrix(data = c(1, 0.5, 0.5, 0.5, 1, 0.5, 0.5, 0.5, 1), nrow = 3)
#'
#' x1 <- rnorm(N)
#' x2 <- rnorm(N)
#' x3 <- rnorm(N)
#'
#' x <- cbind(x1, x2, x3)
#' x <- mx + x %*% chol(Sigmax)
#'
#' A <- matrix(data = c(4, -2, 1, 2, 5, -1), nrow = 2, byrow = TRUE)
#' y <- t(A %*% t(x))
#'
#' x <- data.frame(x)
#'
#' M <- 25
#'
#' # Calculate sensitivity indices
#' sensitivity_indices <- ot_indices(x, y, M)
#' print(sensitivity_indices)
#'
#' # With extended output
#' sensitivity_indices_extended <- ot_indices(x, y, M, extended_out = TRUE)
#' print(sensitivity_indices_extended)
#'
print.gsaot_indices <- function(x, data = FALSE, ...) {
  cat("Method:", x$method, "\n")
  cat("Indices:\n")
  print(x$indices)
  cat("Upper bound:", x$bound, "\n")
  # if (exists("inner_statistics", where = x)) {
  #   cat("Inner statistics:\n")
  #   print(x$inner_statistics)
  #   cat("Partitions:\n")
  #   print(x$partitions)
  # }
  if (data) {
    cat("Data:\n")
    print(x$x)
    print(x$y)
  }
}

#' Plot Optimal Transport sensitivity indices information
#'
#' Plot Optimal Transport based sensitivity indices.
#'
#' @param x An object generated by \code{\link{ot_indices}}, \code{\link{ot_indices_1d}}, or \code{\link{ot_indices_wb}}.
#' @param ... Further arguments passed to or from other methods.
#'
#' @export
#'
#' @examples
#' N <- 1000
#'
#' mx <- c(1, 1, 1)
#' Sigmax <- matrix(data = c(1, 0.5, 0.5, 0.5, 1, 0.5, 0.5, 0.5, 1), nrow = 3)
#'
#' x1 <- rnorm(N)
#' x2 <- rnorm(N)
#' x3 <- rnorm(N)
#'
#' x <- cbind(x1, x2, x3)
#' x <- mx + x %*% chol(Sigmax)
#'
#' A <- matrix(data = c(4, -2, 1, 2, 5, -1), nrow = 2, byrow = TRUE)
#' y <- t(A %*% t(x))
#'
#' x <- data.frame(x)
#'
#' M <- 25
#'
#' # Calculate sensitivity indices
#' sensitivity_indices <- ot_indices(x, y, M)
#' sensitivity_indices
#'
#' plot(sensitivity_indices)
#'
#' # With extended output
#' sensitivity_indices_extended <- ot_indices(x, y, M, extended_out = TRUE)
#' sensitivity_indices_extended
#'
#' plot(sensitivity_indices_extended)
#'
plot.gsaot_indices <- function(x, ...) {
  # If the indices are not from ot_indices_wb, print only the indices
  # Otherwise, plot the indices, the advective component and the diffusive one
  if (!exists("adv", where = x)) {
    # Save current plot settings to be restored after
    old_param <- graphics::par(no.readonly = TRUE)

    # Plot the indices
    graphics::par(mfrow=c(1,1))
    graphics::barplot(x$indices[order(x$indices, decreasing = TRUE)],
            ylim = c(0,1), ...)
    graphics::title(main = paste("Indices calculated using", x$method, "solver"),
          xlab = "Input", ylab = "Index")

    # Restore the old settings
    graphics::par(old_param)
  } else {
    # Save current plot settings to be restored after
    old_param <- graphics::par(no.readonly = TRUE)

    # Plot the indices
    graphics::par(mfrow = c(3, 1))
    graphics::barplot(x$indices[order(x$indices, decreasing = TRUE)],
            ylim = c(0,1), ...)
    graphics::title(main = paste("Indices calculated using", x$method, "solver"),
          xlab = "Input", ylab = "Index")
    graphics::barplot(x$adv[order(x$adv, decreasing = TRUE)],
            ylim = c(0,1), ...)
    graphics::title(main = paste("Advective component"),
          xlab = "Input", ylab = "Index")
    graphics::barplot(x$diff[order(x$diff, decreasing = TRUE)],
            ylim = c(0,1), ...)
    graphics::title(main = paste("Diffusive component"),
                    xlab = "Input", ylab = "Index")

    # Restore the old settings
    graphics::par(old_param)
  }
}

#' Plot Optimal Transport inner statistics
#'
#' Plot Optimal Transport based inner statistics for each partition.
#'
#' @param x An object generated by \code{\link{ot_indices}}, \code{\link{ot_indices_1d}}, or \code{\link{ot_indices_wb}}.
#' @param ... Further arguments passed to or from other methods.
#'
#' @export
#'
#' @examples
#' N <- 1000
#'
#' mx <- c(1, 1, 1)
#' Sigmax <- matrix(data = c(1, 0.5, 0.5, 0.5, 1, 0.5, 0.5, 0.5, 1), nrow = 3)
#'
#' x1 <- rnorm(N)
#' x2 <- rnorm(N)
#' x3 <- rnorm(N)
#'
#' x <- cbind(x1, x2, x3)
#' x <- mx + x %*% chol(Sigmax)
#'
#' A <- matrix(data = c(4, -2, 1, 2, 5, -1), nrow = 2, byrow = TRUE)
#' y <- t(A %*% t(x))
#'
#' x <- data.frame(x)
#'
#' M <- 25
#'
#' # With extended output
#' sensitivity_indices_extended <- ot_indices(x, y, M, extended_out = TRUE)
#' plot_inner_stats(sensitivity_indices_extended)
#'
plot_inner_stats <- function(x, ...) {
  if (!exists("inner_statistics", where = x))
    stop("You have to save the inner statistics (use extended_out=TRUE)")

  # Save current plot settings to be restored after
  old_param <- graphics::par(no.readonly = TRUE)

  # Get the number of inputs
  K <- ncol(x$x)

  # Set the environment
  graphics::par(mfrow = c(K, 1))
  if (x$method == "wasserstein-bures") graphics::par(mfrow = c(K, 3))

  # Get the extrema for each set of inputs for the plot
  min_checkNA <- function(.x) {
    if(any(is.na(as.numeric(.x)))) NA
    else min(as.numeric(.x))
  }
  max_checkNA <- function(.x) {
    if(any(is.na(as.numeric(.x)))) NA
    else max(as.numeric(.x))
  }
  suppressWarnings(x_mins <- apply(x$x, 2, min_checkNA))
  suppressWarnings(x_maxs <- apply(x$x, 2, max_checkNA))

  for (k in seq(K)) {
    partition <- x$partitions[[k]]
    M <- length(partition)

    # If the input is numeric, get the mean of each partition as a x-point to be plotted
    if (is.numeric(x$x[, k])) {
      x_means <- array(dim = M)

      for (m in seq(M))
        x_means[m] <- mean(x$x[partition[[m]], k])

      # Set the limits if numeric
      xlim <- c(x_mins[k], x_maxs[k])

      # Plot the inner statistics
      graphics::plot(x_means, x$inner_statistics[[k]][1, ],
                     xlim = xlim,  ylim = c(0, 1),
                     xlab = "Input", ylab = "Index")
      graphics::title(main = paste("Indices calculated using", x$method, "solver"))

      # Plot the advective and diffusive components if wb
      if (x$method == "wasserstein-bures") {
        plot(x_means, x$inner_statistics[[k]][2, ],
             xlim = xlim, ylim = c(0, 1),
             xlab = "Input", ylab = "Index")
        graphics::title(main = paste("Advective component"),
                        xlab = "Input", ylab = "Index")
        plot(x_means, x$inner_statistics[[k]][3, ],
             xlim = xlim,  ylim = c(0, 1),
             xlab = "Input", ylab = "Index")
        graphics::title(main = paste("Diffusive component"),
                        xlab = "Input", ylab = "Index")
      }
    } else {
    # If the input is non-numeric, use barplot
      if (is.factor(x$x[, k])) {
        x_unique <- levels(x$x[, k])
      } else {
        x_unique <- unique(x$x[, k])
      }

      # Plot the inner statistics
      graphics::barplot(x$inner_statistics[[k]][1, ],
                        names.arg = x_unique,  ylim = c(0, 1),
                        xlab = "Input", ylab = "Index")
      graphics::title(main = paste("Indices calculated using", x$method, "solver"))

      # Plot the advective and diffusive components if wb
      if (x$method == "wasserstein-bures") {
        graphics::barplot(x$inner_statistics[[k]][2, ],
                          names.arg = x_unique,  ylim = c(0, 1),
                          xlab = "Input", ylab = "Index")
        graphics::title(main = paste("Advective component"),
                        xlab = "Input", ylab = "Index")
        graphics::barplot(x$inner_statistics[[k]][3, ],
                          names.arg = x_unique,  ylim = c(0, 1),
                          xlab = "Input", ylab = "Index")
        graphics::title(main = paste("Diffusive component"),
                        xlab = "Input", ylab = "Index")
      }
    }
  }

  graphics::par(old_param)
}
